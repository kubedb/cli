/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha2

import (
	"reflect"
	"strings"
	"unsafe"

	"kubedb.dev/apimachinery/apis/kubedb"
	v1 "kubedb.dev/apimachinery/apis/kubedb/v1"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/util/intstr"
	clientgoapiv1 "kmodules.xyz/client-go/api/v1"
	core_util "kmodules.xyz/client-go/core/v1"
	monitoringagentapiapiv1 "kmodules.xyz/monitoring-agent-api/api/v1"
	ofstv1 "kmodules.xyz/offshoot-api/api/v1"
	ofstconv "kmodules.xyz/offshoot-api/api/v1/conversion"
	ofstv2 "kmodules.xyz/offshoot-api/api/v2"
	rtconv "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec is an autogenerated conversion function.
func Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(in *ofstv1.PodTemplateSpec, out *ofstv2.PodTemplateSpec, s conversion.Scope) error {
	return ofstconv.Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(in, out, s)
}

// Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec is an autogenerated conversion function.
func Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(in *ofstv2.PodTemplateSpec, out *ofstv1.PodTemplateSpec, s conversion.Scope) error {
	return ofstconv.Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(in, out, s)
}

// Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec is an autogenerated conversion function.
func Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(in *[]corev1.Container, out *CoordinatorSpec, s conversion.Scope) error {
	var container *corev1.Container
	for i := range *in {
		if strings.HasSuffix((*in)[i].Name, "coordinator") || (*in)[i].Name == kubedb.ReplicationModeDetectorContainerName {
			container = &(*in)[i]
		}
	}
	if container == nil || (container.Resources.Requests == nil && container.Resources.Limits == nil) {
		return nil
	}
	out.Resources = *container.Resources.DeepCopy()
	out.SecurityContext = container.SecurityContext
	return nil
}

// Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container is an autogenerated conversion function.
func Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(in *CoordinatorSpec, out *[]corev1.Container, s conversion.Scope) error {
	if in == nil {
		return nil
	}

	var container corev1.Container
	container.SecurityContext = (*corev1.SecurityContext)(unsafe.Pointer(in.SecurityContext))
	container.Resources = *in.Resources.DeepCopy()
	found := false

	for i := range *out {
		if strings.HasSuffix((*out)[i].Name, "coordinator") || (*out)[i].Name == kubedb.ReplicationModeDetectorContainerName {
			if container.SecurityContext != nil {
				(*out)[i].SecurityContext = container.SecurityContext
			}
			if container.Resources.Limits != nil || container.Resources.Requests != nil {
				(*out)[i].Resources = *container.Resources.DeepCopy()
			}
			found = true
		}
	}
	if !found && (container.SecurityContext != nil || container.Resources.Limits != nil || container.Resources.Requests != nil) {
		*out = append(*out, container)
	}

	return nil
}

func Convert_v1_ElasticsearchNode_To_v1alpha2_ElasticsearchNode(in *v1.ElasticsearchNode, out *ElasticsearchNode, s conversion.Scope) error {
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Suffix = in.Suffix
	out.HeapSizePercentage = (*int32)(unsafe.Pointer(in.HeapSizePercentage))
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.MaxUnavailable = (*intstr.IntOrString)(unsafe.Pointer(in.MaxUnavailable))
	out.NodeSelector = *(*map[string]string)(unsafe.Pointer(&in.PodTemplate.Spec.NodeSelector))
	out.Tolerations = *(*[]corev1.Toleration)(unsafe.Pointer(&in.PodTemplate.Spec.Tolerations))
	dbContainer := core_util.GetContainerByName(in.PodTemplate.Spec.Containers, kubedb.ElasticsearchContainerName)
	if dbContainer != nil {
		out.Resources = *(*corev1.ResourceRequirements)(unsafe.Pointer(&dbContainer.Resources))
	}
	return nil
}

func Convert_v1alpha2_ElasticsearchNode_To_v1_ElasticsearchNode(in *ElasticsearchNode, out *v1.ElasticsearchNode, s conversion.Scope) error {
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Suffix = in.Suffix
	out.HeapSizePercentage = (*int32)(unsafe.Pointer(in.HeapSizePercentage))
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.MaxUnavailable = (*intstr.IntOrString)(unsafe.Pointer(in.MaxUnavailable))
	out.PodTemplate.Spec.NodeSelector = *(*map[string]string)(unsafe.Pointer(&in.NodeSelector))
	out.PodTemplate.Spec.Tolerations = *(*[]corev1.Toleration)(unsafe.Pointer(&in.Tolerations))
	out.PodTemplate.Spec.Containers = core_util.UpsertContainer(out.PodTemplate.Spec.Containers, corev1.Container{
		Name:      kubedb.ElasticsearchContainerName,
		Resources: in.Resources,
	})
	return nil
}

func Convert_v1alpha2_MariaDBSpec_To_v1_MariaDBSpec(in *MariaDBSpec, out *v1.MariaDBSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.WsrepSSTMethod = v1.GaleraWsrepSSTMethod(in.WsrepSSTMethod)
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.MariaDBContainerName // db container name used in petSet
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.RequireSSL = in.RequireSSL
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	// WARNING: in.Coordinator requires manual conversion: does not exist in peer-type
	if err := Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(&in.Coordinator, &out.PodTemplate.Spec.Containers, s); err != nil {
		return err
	}
	for i := range out.PodTemplate.Spec.Containers {
		if out.PodTemplate.Spec.Containers[i].Name == "" {
			out.PodTemplate.Spec.Containers[i].Name = kubedb.MariaDBCoordinatorContainerName
		}
	}
	out.AllowedSchemas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*v1.Archiver)(unsafe.Pointer(in.Archiver))
	return nil
}

func Convert_v1_MariaDBSpec_To_v1alpha2_MariaDBSpec(in *v1.MariaDBSpec, out *MariaDBSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.WsrepSSTMethod = GaleraWsrepSSTMethod(in.WsrepSSTMethod)
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.RequireSSL = in.RequireSSL
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.AllowedSchemas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*Archiver)(unsafe.Pointer(in.Archiver))
	return nil
}

func Convert_v1alpha2_PostgresSpec_To_v1_PostgresSpec(in *PostgresSpec, out *v1.PostgresSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.StandbyMode = (*v1.PostgresStandbyMode)(unsafe.Pointer(in.StandbyMode))
	out.StreamingMode = (*v1.PostgresStreamingMode)(unsafe.Pointer(in.StreamingMode))
	out.Mode = (*v1.PostgreSQLMode)(unsafe.Pointer(in.Mode))
	out.RemoteReplica = (*v1.RemoteReplicaSpec)(unsafe.Pointer(in.RemoteReplica))
	out.LeaderElection = (*v1.PostgreLeaderElectionConfig)(unsafe.Pointer(in.LeaderElection))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.ClientAuthMode = v1.PostgresClientAuthMode(in.ClientAuthMode)
	out.SSLMode = v1.PostgresSSLMode(in.SSLMode)
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.PostgresContainerName
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	if err := Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(&in.Coordinator, &out.PodTemplate.Spec.Containers, s); err != nil {
		return err
	}
	for i := range out.PodTemplate.Spec.Containers {
		if out.PodTemplate.Spec.Containers[i].Name == "" {
			out.PodTemplate.Spec.Containers[i].Name = kubedb.PostgresCoordinatorContainerName
		}
	}
	out.EnforceFsGroup = in.EnforceFsGroup
	out.AllowedSchemas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*v1.Archiver)(unsafe.Pointer(in.Archiver))
	out.Arbiter = (*v1.ArbiterSpec)(unsafe.Pointer(in.Arbiter))
	out.Replication = (*v1.PostgresReplication)(unsafe.Pointer(in.Replication))
	return nil
}

func Convert_v1_PostgresSpec_To_v1alpha2_PostgresSpec(in *v1.PostgresSpec, out *PostgresSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.StandbyMode = (*PostgresStandbyMode)(unsafe.Pointer(in.StandbyMode))
	out.StreamingMode = (*PostgresStreamingMode)(unsafe.Pointer(in.StreamingMode))
	out.Mode = (*PostgreSQLMode)(unsafe.Pointer(in.Mode))
	out.RemoteReplica = (*RemoteReplicaSpec)(unsafe.Pointer(in.RemoteReplica))
	out.LeaderElection = (*PostgreLeaderElectionConfig)(unsafe.Pointer(in.LeaderElection))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.ClientAuthMode = PostgresClientAuthMode(in.ClientAuthMode)
	out.SSLMode = PostgresSSLMode(in.SSLMode)
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.EnforceFsGroup = in.EnforceFsGroup
	out.AllowedSchemas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*Archiver)(unsafe.Pointer(in.Archiver))
	out.Arbiter = (*ArbiterSpec)(unsafe.Pointer(in.Arbiter))
	out.Replication = (*PostgresReplication)(unsafe.Pointer(in.Replication))
	return nil
}

func Convert_v1alpha2_MySQLRouterSpec_To_v1_MySQLRouterSpec(in *MySQLRouterSpec, out *v1.MySQLRouterSpec, s conversion.Scope) error {
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if in.PodTemplate != nil {
		in, out := &in.PodTemplate, &out.PodTemplate
		*out = new(ofstv2.PodTemplateSpec)
		if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(*in, *out, s); err != nil {
			return err
		}
		(*out).Spec.Containers[0].Name = kubedb.MySQLRouterContainerName
	} else {
		out.PodTemplate = nil
	}
	return nil
}

func Convert_v1alpha2_MySQLSpec_To_v1_MySQLSpec(in *MySQLSpec, out *v1.MySQLSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if in.Topology != nil {
		in, out := &in.Topology, &out.Topology
		*out = new(v1.MySQLTopology)
		if err := Convert_v1alpha2_MySQLTopology_To_v1_MySQLTopology(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Topology = nil
	}
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.MySQLContainerName
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.RequireSSL = in.RequireSSL
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.UseAddressType = v1.AddressType(in.UseAddressType)
	// WARNING: in.Coordinator requires manual conversion: does not exist in peer-type
	if err := Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(&in.Coordinator, &out.PodTemplate.Spec.Containers, s); err != nil {
		return err
	}
	for i := range out.PodTemplate.Spec.Containers {
		if out.PodTemplate.Spec.Containers[i].Name == "" {
			out.PodTemplate.Spec.Containers[i].Name = kubedb.MySQLCoordinatorContainerName
		}
	}
	out.AllowedSchemas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.AllowedReadReplicas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedReadReplicas))
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*v1.Archiver)(unsafe.Pointer(in.Archiver))
	return nil
}

func Convert_v1_MySQLSpec_To_v1alpha2_MySQLSpec(in *v1.MySQLSpec, out *MySQLSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if in.Topology != nil {
		in, out := &in.Topology, &out.Topology
		*out = new(MySQLTopology)
		if err := Convert_v1_MySQLTopology_To_v1alpha2_MySQLTopology(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Topology = nil
	}
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.RequireSSL = in.RequireSSL
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.UseAddressType = AddressType(in.UseAddressType)
	out.AllowedSchemas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.AllowedReadReplicas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedReadReplicas))
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*Archiver)(unsafe.Pointer(in.Archiver))
	return nil
}

func Convert_v1alpha2_MongoHiddenNode_To_v1_MongoHiddenNode(in *MongoHiddenNode, out *v1.MongoHiddenNode, s conversion.Scope) error {
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if out.PodTemplate == nil {
		out.PodTemplate = &ofstv2.PodTemplateSpec{}
	}
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.MongoDBContainerName
	}
	out.Replicas = in.Replicas
	out.Storage = in.Storage
	return nil
}

func Convert_v1_MongoHiddenNode_To_v1alpha2_MongoHiddenNode(in *v1.MongoHiddenNode, out *MongoHiddenNode, s conversion.Scope) error {
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if in.PodTemplate != nil {
		if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(in.PodTemplate, &out.PodTemplate, s); err != nil {
			return err
		}
	}
	out.Replicas = in.Replicas
	out.Storage = in.Storage
	return nil
}

func Convert_v1_MongoDBNode_To_v1alpha2_MongoDBNode(in *v1.MongoDBNode, out *MongoDBNode, s conversion.Scope) error {
	out.Replicas = in.Replicas
	out.Prefix = in.Prefix
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if in.PodTemplate != nil {
		if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(in.PodTemplate, &out.PodTemplate, s); err != nil {
			return err
		}
	}
	return nil
}

func Convert_v1alpha2_MongoDBNode_To_v1_MongoDBNode(in *MongoDBNode, out *v1.MongoDBNode, s conversion.Scope) error {
	out.Replicas = in.Replicas
	out.Prefix = in.Prefix
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if out.PodTemplate == nil {
		out.PodTemplate = &ofstv2.PodTemplateSpec{}
	}
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.MongoDBContainerName
	}
	return nil
}

func Convert_v1_MongoArbiterNode_To_v1alpha2_MongoArbiterNode(in *v1.MongoArbiterNode, out *MongoArbiterNode, s conversion.Scope) error {
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if in.PodTemplate != nil {
		if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(in.PodTemplate, &out.PodTemplate, s); err != nil {
			return err
		}
	}
	return nil
}

func Convert_v1alpha2_MongoArbiterNode_To_v1_MongoArbiterNode(in *MongoArbiterNode, out *v1.MongoArbiterNode, s conversion.Scope) error {
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if out.PodTemplate == nil {
		out.PodTemplate = &ofstv2.PodTemplateSpec{}
	}
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.MongoDBContainerName
	}
	return nil
}

func initializeMongoDBReplicationModeDetectorContainer(in *CoordinatorSpec, podTemplate *ofstv2.PodTemplateSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(in, &podTemplate.Spec.Containers, s); err != nil {
		return err
	}
	for i := range podTemplate.Spec.Containers {
		if podTemplate.Spec.Containers[i].Name == "" {
			podTemplate.Spec.Containers[i].Name = kubedb.ReplicationModeDetectorContainerName
		}
	}
	return nil
}

func Convert_v1alpha2_MongoDBSpec_To_v1_MongoDBSpec(in *MongoDBSpec, out *v1.MongoDBSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.ReplicaSet = (*v1.MongoDBReplicaSet)(unsafe.Pointer(in.ReplicaSet))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.EphemeralStorage = (*corev1.EmptyDirVolumeSource)(unsafe.Pointer(in.EphemeralStorage))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.ClusterAuthMode = v1.ClusterAuthMode(in.ClusterAuthMode)
	out.SSLMode = v1.SSLMode(in.SSLMode)
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if in.ShardTopology != nil {
		in, out := &in.ShardTopology, &out.ShardTopology
		*out = new(v1.MongoDBShardingTopology)
		if err := Convert_v1alpha2_MongoDBShardingTopology_To_v1_MongoDBShardingTopology(*in, *out, s); err != nil {
			return err
		}
	} else {
		if in.PodTemplate != nil {
			in, out := &in.PodTemplate, &out.PodTemplate
			*out = new(ofstv2.PodTemplateSpec)
			if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(*in, *out, s); err != nil {
				return err
			}
			if len((*out).Spec.Containers) > 0 {
				(*out).Spec.Containers[0].Name = kubedb.MongoDBContainerName // db container name used in petSet
			}
		} else {
			out := &out.PodTemplate
			*out = new(ofstv2.PodTemplateSpec)
			(*out).Spec.Containers = append((*out).Spec.Containers, corev1.Container{
				Name: kubedb.MongoDBContainerName,
			})
		}
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.KeyFileSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.KeyFileSecret))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.StorageEngine = v1.StorageEngine(in.StorageEngine)
	// WARNING: in.Coordinator requires manual conversion: does not exist in peer-type

	if !reflect.ValueOf(in.Coordinator).IsZero() {
		if out.ShardTopology != nil {
			if out.ShardTopology.Shard.PodTemplate == nil {
				out.ShardTopology.Shard.PodTemplate = new(ofstv2.PodTemplateSpec)
			}
			if err := initializeMongoDBReplicationModeDetectorContainer(&in.Coordinator, out.ShardTopology.Shard.PodTemplate, s); err != nil {
				return err
			}
			if out.ShardTopology.ConfigServer.PodTemplate == nil {
				out.ShardTopology.ConfigServer.PodTemplate = new(ofstv2.PodTemplateSpec)
			}
			if err := initializeMongoDBReplicationModeDetectorContainer(&in.Coordinator, out.ShardTopology.ConfigServer.PodTemplate, s); err != nil {
				return err
			}
		} else {
			if out.PodTemplate == nil {
				out.PodTemplate = new(ofstv2.PodTemplateSpec)
			}
			if err := initializeMongoDBReplicationModeDetectorContainer(&in.Coordinator, out.PodTemplate, s); err != nil {
				return err
			}
		}
	}
	out.AllowedSchemas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	if in.Arbiter != nil {
		in, out := &in.Arbiter, &out.Arbiter
		*out = new(v1.MongoArbiterNode)
		if err := Convert_v1alpha2_MongoArbiterNode_To_v1_MongoArbiterNode(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Arbiter = nil
	}
	if in.Hidden != nil {
		in, out := &in.Hidden, &out.Hidden
		*out = new(v1.MongoHiddenNode)
		if err := Convert_v1alpha2_MongoHiddenNode_To_v1_MongoHiddenNode(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Hidden = nil
	}
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*v1.Archiver)(unsafe.Pointer(in.Archiver))
	return nil
}

func Convert_v1_MongoDBSpec_To_v1alpha2_MongoDBSpec(in *v1.MongoDBSpec, out *MongoDBSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.ReplicaSet = (*MongoDBReplicaSet)(unsafe.Pointer(in.ReplicaSet))
	if in.ShardTopology != nil {
		inSt, outSt := &in.ShardTopology, &out.ShardTopology
		*outSt = new(MongoDBShardingTopology)
		if err := Convert_v1_MongoDBShardingTopology_To_v1alpha2_MongoDBShardingTopology(*inSt, *outSt, s); err != nil {
			return err
		}
		if in.ShardTopology.Shard.PodTemplate != nil {
			if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.ShardTopology.Shard.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
				return err
			}
		}
	} else {
		out.ShardTopology = nil
	}
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.EphemeralStorage = (*corev1.EmptyDirVolumeSource)(unsafe.Pointer(in.EphemeralStorage))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.ClusterAuthMode = ClusterAuthMode(in.ClusterAuthMode)
	out.SSLMode = SSLMode(in.SSLMode)
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if in.PodTemplate != nil {
		inPt, outPt := &in.PodTemplate, &out.PodTemplate
		*outPt = new(ofstv1.PodTemplateSpec)
		if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(*inPt, *outPt, s); err != nil {
			return err
		}
		if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
			return err
		}
	} else {
		out.PodTemplate = nil
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.KeyFileSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.KeyFileSecret))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.StorageEngine = StorageEngine(in.StorageEngine)
	out.AllowedSchemas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	if in.Arbiter != nil {
		in, out := &in.Arbiter, &out.Arbiter
		*out = new(MongoArbiterNode)
		if err := Convert_v1_MongoArbiterNode_To_v1alpha2_MongoArbiterNode(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Arbiter = nil
	}
	if in.Hidden != nil {
		in, out := &in.Hidden, &out.Hidden
		*out = new(MongoHiddenNode)
		if err := Convert_v1_MongoHiddenNode_To_v1alpha2_MongoHiddenNode(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Hidden = nil
	}
	out.HealthChecker = in.HealthChecker
	out.Archiver = (*Archiver)(unsafe.Pointer(in.Archiver))
	return nil
}

func Convert_v1alpha2_RedisClusterSpec_To_v1_RedisClusterSpec(in *RedisClusterSpec, out *v1.RedisClusterSpec, s conversion.Scope) error {
	if in.Master != nil {
		out.Shards = (*int32)(unsafe.Pointer(in.Master))
	} else {
		out.Shards = nil
	}

	if in.Replicas != nil {
		convert := func(i int32) *int32 {
			p := new(int32)
			*p = i
			return p
		}
		out.Replicas = convert(*in.Replicas + 1)
	} else {
		out.Replicas = nil
	}
	return nil
}

func Convert_v1alpha2_RedisSpec_To_v1_RedisSpec(in *RedisSpec, out *v1.RedisSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}

	if in.Mode == RedisModeCluster {
		if out.Cluster == nil {
			out.Cluster = &v1.RedisClusterSpec{}
		}
		if err := Convert_v1alpha2_RedisClusterSpec_To_v1_RedisClusterSpec(in.Cluster, out.Cluster, s); err != nil {
			return err
		}
	}

	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Mode = v1.RedisMode(in.Mode)
	out.SentinelRef = (*v1.RedisSentinelRef)(unsafe.Pointer(in.SentinelRef))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.DisableAuth = in.DisableAuth
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.RedisContainerName
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	// WARNING: in.Coordinator requires manual conversion: does not exist in peer-type
	if err := Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(&in.Coordinator, &out.PodTemplate.Spec.Containers, s); err != nil {
		return err
	}
	for i := range out.PodTemplate.Spec.Containers {
		if out.PodTemplate.Spec.Containers[i].Name == "" {
			out.PodTemplate.Spec.Containers[i].Name = kubedb.RedisCoordinatorContainerName
		}
	}
	out.AllowedSchemas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1_RedisClusterSpec_To_v1alpha2_RedisClusterSpec(in *v1.RedisClusterSpec, out *RedisClusterSpec, s conversion.Scope) error {
	if in.Shards != nil {
		out.Master = (*int32)(unsafe.Pointer(in.Shards))
	} else {
		out.Master = nil
	}

	if in.Replicas != nil {
		convert := func(i int32) *int32 {
			p := new(int32)
			*p = i
			return p
		}
		out.Replicas = convert(*in.Replicas - 1)
	} else {
		out.Replicas = nil
	}

	return nil
}

func Convert_v1_RedisSpec_To_v1alpha2_RedisSpec(in *v1.RedisSpec, out *RedisSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}

	if in.Mode == v1.RedisModeCluster {
		if out.Cluster == nil {
			out.Cluster = &RedisClusterSpec{}
		}
		if err := Convert_v1_RedisClusterSpec_To_v1alpha2_RedisClusterSpec(in.Cluster, out.Cluster, s); err != nil {
			return err
		}
	}

	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Mode = RedisMode(in.Mode)
	out.SentinelRef = (*RedisSentinelRef)(unsafe.Pointer(in.SentinelRef))
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.DisableAuth = in.DisableAuth
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.AllowedSchemas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1alpha2_PerconaXtraDBSpec_To_v1_PerconaXtraDBSpec(in *PerconaXtraDBSpec, out *v1.PerconaXtraDBSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.PerconaXtraDBContainerName
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.RequireSSL = in.RequireSSL
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	// WARNING: in.Coordinator requires manual conversion: does not exist in peer-type
	if err := Convert_v1alpha2_CoordinatorSpec_To_Slice_v1_Container(&in.Coordinator, &out.PodTemplate.Spec.Containers, s); err != nil {
		return err
	}
	for i := range out.PodTemplate.Spec.Containers {
		if out.PodTemplate.Spec.Containers[i].Name == "" {
			out.PodTemplate.Spec.Containers[i].Name = kubedb.PerconaXtraDBCoordinatorContainerName
		}
	}

	out.AllowedSchemas = (*v1.AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	out.SystemUserSecrets = (*v1.SystemUserSecretsSpec)(unsafe.Pointer(in.SystemUserSecrets))
	return nil
}

func Convert_v1_PerconaXtraDBSpec_To_v1alpha2_PerconaXtraDBSpec(in *v1.PerconaXtraDBSpec, out *PerconaXtraDBSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}

	if err := Convert_Slice_v1_Container_To_v1alpha2_CoordinatorSpec(&in.PodTemplate.Spec.Containers, &out.Coordinator, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.RequireSSL = in.RequireSSL
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.AllowedSchemas = (*AllowedConsumers)(unsafe.Pointer(in.AllowedSchemas))
	out.HealthChecker = in.HealthChecker
	out.SystemUserSecrets = (*SystemUserSecretsSpec)(unsafe.Pointer(in.SystemUserSecrets))
	return nil
}

func Convert_v1alpha2_ElasticsearchSpec_To_v1_ElasticsearchSpec(in *ElasticsearchSpec, out *v1.ElasticsearchSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if in.Topology != nil {
		in, out := &in.Topology, &out.Topology
		*out = new(v1.ElasticsearchClusterTopology)
		if err := Convert_v1alpha2_ElasticsearchClusterTopology_To_v1_ElasticsearchClusterTopology(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Topology = nil
	}
	out.EnableSSL = in.EnableSSL
	out.DisableSecurity = in.DisableSecurity
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.Init = (*v1.InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	out.SecureConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.SecureConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.ElasticsearchContainerName
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.MaxUnavailable = (*intstr.IntOrString)(unsafe.Pointer(in.MaxUnavailable))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.InternalUsers = *(*map[string]v1.ElasticsearchUserSpec)(unsafe.Pointer(&in.InternalUsers))
	out.RolesMapping = *(*map[string]v1.ElasticsearchRoleMapSpec)(unsafe.Pointer(&in.RolesMapping))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.KernelSettings = (*v1.KernelSettings)(unsafe.Pointer(in.KernelSettings))
	out.HeapSizePercentage = (*int32)(unsafe.Pointer(in.HeapSizePercentage))
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1alpha2_KafkaNode_To_v1_KafkaNode(in *KafkaNode, out *v1.KafkaNode, s conversion.Scope) error {
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Suffix = in.Suffix
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.PodTemplate.Spec.NodeSelector = *(*map[string]string)(unsafe.Pointer(&in.NodeSelector))
	out.PodTemplate.Spec.Tolerations = *(*[]corev1.Toleration)(unsafe.Pointer(&in.Tolerations))
	out.PodTemplate.Spec.Containers = core_util.UpsertContainer(out.PodTemplate.Spec.Containers, corev1.Container{
		Name:      kubedb.KafkaContainerName,
		Resources: in.Resources,
	})
	return nil
}

func Convert_v1_KafkaNode_To_v1alpha2_KafkaNode(in *v1.KafkaNode, out *KafkaNode, s conversion.Scope) error {
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Suffix = in.Suffix
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.NodeSelector = *(*map[string]string)(unsafe.Pointer(&in.PodTemplate.Spec.NodeSelector))
	out.Tolerations = *(*[]corev1.Toleration)(unsafe.Pointer(&in.PodTemplate.Spec.Tolerations))
	dbContainer := core_util.GetContainerByName(in.PodTemplate.Spec.Containers, kubedb.KafkaContainerName)
	if dbContainer != nil {
		out.Resources = *(*corev1.ResourceRequirements)(unsafe.Pointer(&dbContainer.Resources))
	}
	return nil
}

func Convert_v1alpha2_MemcachedSpec_To_v1_MemcachedSpec(in *MemcachedSpec, out *v1.MemcachedSpec, s conversion.Scope) error {
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	out.DataVolume = (*corev1.VolumeSource)(unsafe.Pointer(in.DataVolume))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if len(out.PodTemplate.Spec.Containers) > 0 {
		out.PodTemplate.Spec.Containers[0].Name = kubedb.MemcachedContainerName
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1_ElasticsearchSpec_To_v1alpha2_ElasticsearchSpec(in *v1.ElasticsearchSpec, out *ElasticsearchSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if in.Topology != nil {
		in, out := &in.Topology, &out.Topology
		*out = new(ElasticsearchClusterTopology)
		if err := Convert_v1_ElasticsearchClusterTopology_To_v1alpha2_ElasticsearchClusterTopology(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Topology = nil
	}
	out.EnableSSL = in.EnableSSL
	out.DisableSecurity = in.DisableSecurity
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.Init = (*InitSpec)(unsafe.Pointer(in.Init))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	out.SecureConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.SecureConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.MaxUnavailable = (*intstr.IntOrString)(unsafe.Pointer(in.MaxUnavailable))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.InternalUsers = *(*map[string]ElasticsearchUserSpec)(unsafe.Pointer(&in.InternalUsers))
	out.RolesMapping = *(*map[string]ElasticsearchRoleMapSpec)(unsafe.Pointer(&in.RolesMapping))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.KernelSettings = (*KernelSettings)(unsafe.Pointer(in.KernelSettings))
	out.HeapSizePercentage = (*int32)(unsafe.Pointer(in.HeapSizePercentage))
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1_MemcachedSpec_To_v1alpha2_MemcachedSpec(in *v1.MemcachedSpec, out *MemcachedSpec, s conversion.Scope) error {
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	out.DataVolume = (*corev1.VolumeSource)(unsafe.Pointer(in.DataVolume))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.Halted = in.Halted
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1alpha2_PgBouncerSpec_To_v1_PgBouncerSpec(in *PgBouncerSpec, out *v1.PgBouncerSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if err := Convert_v1alpha2_Database_To_v1_Database(&in.Database, &out.Database, s); err != nil {
		return err
	}
	out.ConnectionPool = (*v1.ConnectionPoolConfig)(unsafe.Pointer(in.ConnectionPool))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.SSLMode = v1.PgBouncerSSLMode(in.SSLMode)
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1_PgBouncerSpec_To_v1alpha2_PgBouncerSpec(in *v1.PgBouncerSpec, out *PgBouncerSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	if err := Convert_v1_Database_To_v1alpha2_Database(&in.Database, &out.Database, s); err != nil {
		return err
	}
	out.ConnectionPool = (*ConnectionPoolConfig)(unsafe.Pointer(in.ConnectionPool))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.SSLMode = PgBouncerSSLMode(in.SSLMode)
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.TerminationPolicy = PgBouncerTerminationPolicy(in.DeletionPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1alpha2_ProxySQLSpec_To_v1_ProxySQLSpec(in *ProxySQLSpec, out *v1.ProxySQLSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.SyncUsers = in.SyncUsers
	out.InitConfiguration = (*v1.ProxySQLConfiguration)(unsafe.Pointer(in.InitConfiguration))
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Backend = (*corev1.LocalObjectReference)(unsafe.Pointer(in.Backend))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1_ProxySQLSpec_To_v1alpha2_ProxySQLSpec(in *v1.ProxySQLSpec, out *ProxySQLSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.SyncUsers = in.SyncUsers
	out.InitConfiguration = (*ProxySQLConfiguration)(unsafe.Pointer(in.InitConfiguration))
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	out.Backend = (*corev1.LocalObjectReference)(unsafe.Pointer(in.Backend))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.ConfigSecret = (*corev1.LocalObjectReference)(unsafe.Pointer(in.ConfigSecret))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1alpha2_RedisSentinelSpec_To_v1_RedisSentinelSpec(in *RedisSentinelSpec, out *v1.RedisSentinelSpec, s conversion.Scope) error {
	if err := Convert_v1alpha2_AutoOpsSpec_To_v1_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if err := Convert_v1_PodTemplateSpec_To_v2_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]v1.NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.StorageType = v1.StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*v1.SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.DisableAuth = in.DisableAuth
	out.Halted = in.Halted
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.DeletionPolicy = v1.DeletionPolicy(in.TerminationPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func Convert_v1_RedisSentinelSpec_To_v1alpha2_RedisSentinelSpec(in *v1.RedisSentinelSpec, out *RedisSentinelSpec, s conversion.Scope) error {
	if err := Convert_v1_AutoOpsSpec_To_v1alpha2_AutoOpsSpec(&in.AutoOps, &out.AutoOps, s); err != nil {
		return err
	}
	out.Version = in.Version
	out.Replicas = (*int32)(unsafe.Pointer(in.Replicas))
	if err := Convert_v2_PodTemplateSpec_To_v1_PodTemplateSpec(&in.PodTemplate, &out.PodTemplate, s); err != nil {
		return err
	}
	out.ServiceTemplates = *(*[]NamedServiceTemplateSpec)(unsafe.Pointer(&in.ServiceTemplates))
	out.TLS = (*clientgoapiv1.TLSConfig)(unsafe.Pointer(in.TLS))
	out.StorageType = StorageType(in.StorageType)
	out.Storage = (*corev1.PersistentVolumeClaimSpec)(unsafe.Pointer(in.Storage))
	out.AuthSecret = (*SecretReference)(unsafe.Pointer(in.AuthSecret))
	out.DisableAuth = in.DisableAuth
	out.Halted = in.Halted
	out.Monitor = (*monitoringagentapiapiv1.AgentSpec)(unsafe.Pointer(in.Monitor))
	out.TerminationPolicy = TerminationPolicy(in.DeletionPolicy)
	out.HealthChecker = in.HealthChecker
	return nil
}

func (src *Elasticsearch) ConvertTo(dstRaw rtconv.Hub) error {
	dst := dstRaw.(*v1.Elasticsearch)
	err := Convert_v1alpha2_Elasticsearch_To_v1_Elasticsearch(src, dst, nil)
	if err != nil {
		return err
	}
	return nil
}

func (dst *Elasticsearch) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_Elasticsearch_To_v1alpha2_Elasticsearch(srcRaw.(*v1.Elasticsearch), dst, nil)
}

func (src *MariaDB) ConvertTo(dstRaw rtconv.Hub) error {
	dst := dstRaw.(*v1.MariaDB)
	err := Convert_v1alpha2_MariaDB_To_v1_MariaDB(src, dst, nil)
	if err != nil {
		return err
	}
	return nil
}

func (dst *MariaDB) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_MariaDB_To_v1alpha2_MariaDB(srcRaw.(*v1.MariaDB), dst, nil)
}

func (src *MongoDB) ConvertTo(dstRaw rtconv.Hub) error {
	return Convert_v1alpha2_MongoDB_To_v1_MongoDB(src, dstRaw.(*v1.MongoDB), nil)
}

func (dst *MongoDB) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_MongoDB_To_v1alpha2_MongoDB(srcRaw.(*v1.MongoDB), dst, nil)
}

func (src *Memcached) ConvertTo(dstRaw rtconv.Hub) error {
	return Convert_v1alpha2_Memcached_To_v1_Memcached(src, dstRaw.(*v1.Memcached), nil)
}

func (dst *Memcached) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_Memcached_To_v1alpha2_Memcached(srcRaw.(*v1.Memcached), dst, nil)
}

func (src *MySQL) ConvertTo(dstRaw rtconv.Hub) error {
	return Convert_v1alpha2_MySQL_To_v1_MySQL(src, dstRaw.(*v1.MySQL), nil)
}

func (dst *MySQL) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_MySQL_To_v1alpha2_MySQL(srcRaw.(*v1.MySQL), dst, nil)
}

func (src *PerconaXtraDB) ConvertTo(dstRaw rtconv.Hub) error {
	return Convert_v1alpha2_PerconaXtraDB_To_v1_PerconaXtraDB(src, dstRaw.(*v1.PerconaXtraDB), nil)
}

func (dst *PerconaXtraDB) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_PerconaXtraDB_To_v1alpha2_PerconaXtraDB(srcRaw.(*v1.PerconaXtraDB), dst, nil)
}

func (src *PgBouncer) ConvertTo(dstRaw rtconv.Hub) error {
	dst := dstRaw.(*v1.PgBouncer)
	if err := Convert_v1alpha2_PgBouncer_To_v1_PgBouncer(src, dst, nil); err != nil {
		return err
	}
	if len(dst.Spec.PodTemplate.Spec.Containers) > 0 {
		dst.Spec.PodTemplate.Spec.Containers[0].Name = kubedb.PgBouncerContainerName
	}
	return nil
}

func (dst *PgBouncer) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_PgBouncer_To_v1alpha2_PgBouncer(srcRaw.(*v1.PgBouncer), dst, nil)
}

func (src *Postgres) ConvertTo(dstRaw rtconv.Hub) error {
	// return Convert_v1alpha2_Postgres_To_v1_Postgres(src, dstRaw.(*v1.Postgres), nil)
	dst := dstRaw.(*v1.Postgres)
	err := Convert_v1alpha2_Postgres_To_v1_Postgres(src, dst, nil)
	if err != nil {
		return err
	}
	return nil
}

func (dst *Postgres) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_Postgres_To_v1alpha2_Postgres(srcRaw.(*v1.Postgres), dst, nil)
}

func (src *ProxySQL) ConvertTo(dstRaw rtconv.Hub) error {
	dst := dstRaw.(*v1.ProxySQL)
	if err := Convert_v1alpha2_ProxySQL_To_v1_ProxySQL(src, dst, nil); err != nil {
		return err
	}
	if len(dst.Spec.PodTemplate.Spec.Containers) > 0 {
		dst.Spec.PodTemplate.Spec.Containers[0].Name = kubedb.ProxySQLContainerName
	}
	return nil
}

func (dst *ProxySQL) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_ProxySQL_To_v1alpha2_ProxySQL(srcRaw.(*v1.ProxySQL), dst, nil)
}

func (src *RedisSentinel) ConvertTo(dstRaw rtconv.Hub) error {
	dst := dstRaw.(*v1.RedisSentinel)
	if err := Convert_v1alpha2_RedisSentinel_To_v1_RedisSentinel(src, dst, nil); err != nil {
		return err
	}
	if len(dst.Spec.PodTemplate.Spec.Containers) > 0 {
		dst.Spec.PodTemplate.Spec.Containers[0].Name = kubedb.RedisSentinelContainerName
	}
	return nil
}

func (dst *RedisSentinel) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_RedisSentinel_To_v1alpha2_RedisSentinel(srcRaw.(*v1.RedisSentinel), dst, nil)
}

func (src *Redis) ConvertTo(dstRaw rtconv.Hub) error {
	return Convert_v1alpha2_Redis_To_v1_Redis(src, dstRaw.(*v1.Redis), nil)
}

func (dst *Redis) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_Redis_To_v1alpha2_Redis(srcRaw.(*v1.Redis), dst, nil)
}

func (src *Kafka) ConvertTo(dstRaw rtconv.Hub) error {
	return Convert_v1alpha2_Kafka_To_v1_Kafka(src, dstRaw.(*v1.Kafka), nil)
}

func (dst *Kafka) ConvertFrom(srcRaw rtconv.Hub) error {
	return Convert_v1_Kafka_To_v1alpha2_Kafka(srcRaw.(*v1.Kafka), dst, nil)
}
